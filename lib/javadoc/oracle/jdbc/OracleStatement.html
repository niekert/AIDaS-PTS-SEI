<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.4.2_08) on Wed Jun 22 19:25:13 PDT 2005 -->
<TITLE>
OracleStatement (Oracle JDBC API Reference)
</TITLE>

<META NAME="keywords" CONTENT="oracle.jdbc.OracleStatement interface">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="OracleStatement (Oracle JDBC API Reference)";
}
</SCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Oracle JDBC API Reference<br>10<i>g</i> Release 2 ("10.2.0.1.0")</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../oracle/jdbc/OracleSavepoint.html" title="interface in oracle.jdbc"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../oracle/jdbc/StructMetaData.html" title="interface in oracle.jdbc"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="OracleStatement.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>

</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
oracle.jdbc</FONT>
<BR>
Interface OracleStatement</H2>
<DL>
<DT><B>All Superinterfaces:</B> <DD>java.sql.Statement</DD>
</DL>
<DL>
<DT><B>All Known Subinterfaces:</B> <DD><A HREF="../../oracle/jdbc/OracleCallableStatement.html" title="interface in oracle.jdbc">OracleCallableStatement</A>, <A HREF="../../oracle/jdbc/OraclePreparedStatement.html" title="interface in oracle.jdbc">OraclePreparedStatement</A></DD>
</DL>
<HR>
<DL>
<DT>public interface <B>OracleStatement</B><DT>extends java.sql.Statement</DL>

<P>
This interface defines the Oracle extensions to the standard JDBC interface
  <CODE>java.sql.Statement</CODE> and is the superinterface of the
  <CODE>OraclePreparedStatement</CODE> and <CODE>OracleCallableStatement</CODE>
  interfaces. You can use <CODE>java.sql.Statement</CODE> in your application
  where you do not make use of the Oracle extensions. However, when your
  application uses the Oracle extensions to <CODE>java.sql.Statement</CODE> you
  must cast your statement object to the type
  <CODE>oracle.jdbc.OracleStatement</CODE>. Although the type by which the java
  compiler will identify the statement object is changed, the object itself is
  unchanged.

  <P>Extended functionality includes support for settings flags and options for
  Oracle performance extensions on a statement-by-statements basis, as opposed
  to the <CODE>OracleConnection</CODE> interface that sets these on a
  connection-wide basis.
<P>

<P>
<DL>
<DT><B>Since:</B></DT>
  <DD>8.1.7</DD>
<DT><B>See Also:</B><DD><CODE>Connection.createStatement</CODE></DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->


<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Field Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../oracle/jdbc/OracleStatement.html#EXPLICIT">EXPLICIT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../oracle/jdbc/OracleStatement.html#IMPLICIT">IMPLICIT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../oracle/jdbc/OracleStatement.html#NEW">NEW</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;<A NAME="fields_inherited_from_class_java.sql.Statement"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Fields inherited from interface java.sql.Statement</B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>CLOSE_ALL_RESULTS, CLOSE_CURRENT_RESULT, EXECUTE_FAILED, KEEP_CURRENT_RESULT, NO_GENERATED_KEYS, RETURN_GENERATED_KEYS, SUCCESS_NO_INFO</CODE></TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->


<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Method Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../oracle/jdbc/OracleStatement.html#clearDefines()">clearDefines</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Lets you clear previously defined types for the define-columns of this
    statement.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../oracle/jdbc/OracleStatement.html#closeWithKey(java.lang.String)">closeWithKey</A></B>(java.lang.String&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The underlying cursor is not closed and the Statement
    handle is cached on the Key.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../oracle/jdbc/OracleStatement.html#creationState()">creationState</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I></I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../oracle/jdbc/OracleStatement.html#defineColumnType(int, int)">defineColumnType</A></B>(int&nbsp;column_index,
                 int&nbsp;type)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defines the type you will use to retrieve data from a particular database
    table column.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../oracle/jdbc/OracleStatement.html#defineColumnType(int, int, int)">defineColumnType</A></B>(int&nbsp;column_index,
                 int&nbsp;type,
                 int&nbsp;max_size)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defines the type you will use to retrieve data from a particular database
    table column and the maximum size of data you want.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../oracle/jdbc/OracleStatement.html#defineColumnType(int, int, int, short)">defineColumnType</A></B>(int&nbsp;column_index,
                 int&nbsp;type,
                 int&nbsp;max_size,
                 short&nbsp;form_of_use)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defines the type you will use to retrieve data from a particular database
    table column and the maximum size of data you want.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../oracle/jdbc/OracleStatement.html#defineColumnType(int, int, java.lang.String)">defineColumnType</A></B>(int&nbsp;column_index,
                 int&nbsp;typeCode,
                 java.lang.String&nbsp;typeName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defines the type you will use to retrieve data from a particular database
    table column and specifies the column name.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../oracle/jdbc/OracleStatement.html#defineColumnTypeBytes(int, int, int)">defineColumnTypeBytes</A></B>(int&nbsp;column_index,
                      int&nbsp;type,
                      int&nbsp;max_size)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defines the type you will use to retrieve data from a particular database
    table column and the maximum size of data you want, specifying the maximum
    size in <b>bytes</b>, not characters.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../oracle/jdbc/OracleStatement.html#defineColumnTypeChars(int, int, int)">defineColumnTypeChars</A></B>(int&nbsp;column_index,
                      int&nbsp;type,
                      int&nbsp;max_size)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defines the type you will use to retrieve data from a particular database
    table column and the maximum size of data you want, specifying the maximum
    size in <b>characters</b>, rather than bytes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../oracle/jdbc/OracleStatement.html#getRowPrefetch()">getRowPrefetch</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the value or row prefetch for all result sets created from this
    statement.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../oracle/jdbc/OracleStatement.html#isNCHAR(int)">isNCHAR</A></B>(int&nbsp;index)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isNCHAR (int)</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../oracle/jdbc/OracleStatement.html#setResultSetCache(oracle.jdbc.OracleResultSetCache)">setResultSetCache</A></B>(<A HREF="../../oracle/jdbc/OracleResultSetCache.html" title="interface in oracle.jdbc">OracleResultSetCache</A>&nbsp;cache)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Lets you use your own client-side cache implementation for scrollable
    result sets.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../oracle/jdbc/OracleStatement.html#setRowPrefetch(int)">setRowPrefetch</A></B>(int&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the value of row prefetch for all result sets created from this
    statement.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.sql.Statement"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from interface java.sql.Statement</B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>addBatch, cancel, clearBatch, clearWarnings, close, execute, execute, execute, execute, executeBatch, executeQuery, executeUpdate, executeUpdate, executeUpdate, executeUpdate, getConnection, getFetchDirection, getFetchSize, getGeneratedKeys, getMaxFieldSize, getMaxRows, getMoreResults, getMoreResults, getQueryTimeout, getResultSet, getResultSetConcurrency, getResultSetHoldability, getResultSetType, getUpdateCount, getWarnings, setCursorName, setEscapeProcessing, setFetchDirection, setFetchSize, setMaxFieldSize, setMaxRows, setQueryTimeout</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Field Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="NEW"><!-- --></A><H3>
NEW</H3>
<PRE>
public static final int <B>NEW</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#oracle.jdbc.OracleStatement.NEW">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="IMPLICIT"><!-- --></A><H3>
IMPLICIT</H3>
<PRE>
public static final int <B>IMPLICIT</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#oracle.jdbc.OracleStatement.IMPLICIT">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="EXPLICIT"><!-- --></A><H3>
EXPLICIT</H3>
<PRE>
public static final int <B>EXPLICIT</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#oracle.jdbc.OracleStatement.EXPLICIT">Constant Field Values</A></DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->


<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Method Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="clearDefines()"><!-- --></A><H3>
clearDefines</H3>
<PRE>
public void <B>clearDefines</B>()
                  throws java.sql.SQLException</PRE>
<DL>
<DD>Lets you clear previously defined types for the define-columns of this
    statement. This is usefull if you want to reuse this statement for a
    different query.

    <p>After calling <CODE>clearDefines</CODE>, you can either perform defines
    by calling <CODE>defineColumnType/defineColumnTypeChars</CODE> or let the
    driver use the default defines for the table.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if an error occurs</DL>
</DD>
</DL>
<HR>

<A NAME="defineColumnType(int, int)"><!-- --></A><H3>
defineColumnType</H3>
<PRE>
public void <B>defineColumnType</B>(int&nbsp;column_index,
                             int&nbsp;type)
                      throws java.sql.SQLException</PRE>
<DL>
<DD>Defines the type you will use to retrieve data from a particular database
    table column.

    <P>Before executing a query you may choose to inform JDBC of the type you
    will use for fetching data from columns.  This will save 2 roundtrips to
    the RDBMS when executing the query as otherwise the JDBC driver has to ask
    the RDBMS for the column types.

    <P>If you decide to define column types you have to declare the types of
    exactly all columns in the query.  If definition are missing or too many
    definitions are provided <CODE>executeQuery</CODE> will fail with a
    SQLException.

    <P>The following example illustrates the use of this feature:

    <P><PRE>
    Connection conn = DriverManager.getConnection("jdbc:oracle:oci8:","scott","tiger");
    Statement stmt = conn.createStatement();
    // Ask for the column as a string:
    // Avoid a round trip to get the column type.
    // Convert from number to string on the server.

    ((OracleStatement)stmt).defineColumnType(1, Types.VARCHAR);

    ResultSet rset = stmt.executeQuery("select empno from emp");
    while (rset.next() )
    System.out.println(rset.getString(1));
    stmt.close();
    </PRE>

    <P>Notes:<ul>

    <li> All columns can be defined to their "natural" JDBC types; in most
    cases, they can be defined to the <CODE>Types.CHAR</CODE> or
    <CODE>Types.VARCHAR</CODE> typecode. You can also use the
    <CODE>OracleTypes</CODE> typecodes. The type can also be different from the
    native type of the column. Appropriate conversions will be done.  A
    subsequent call to <CODE>getObject()</CODE> for this column will return the
    supplied type rather than the native type, however.

    <li> When reading the value of an out parameter you don't have to use the
    <CODE>getXXX</CODE> method whose Java type XXX corresponds to the
    parameter's registered SQL type.  It's just faster if you do as the data
    has already been converted to the right type.

    </ul>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>column_index</CODE> - index of column (first is 1)<DD><CODE>type</CODE> - type to be assigned to column
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if an error occurs<DT><B>See Also:</B><DD><A HREF="../../oracle/jdbc/OracleStatement.html#defineColumnType(int, int, int)"><CODE>defineColumnType(int,int,int)</CODE></A>, 
<A HREF="../../oracle/jdbc/OracleStatement.html#clearDefines()"><CODE>clearDefines</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="defineColumnType(int, int, int)"><!-- --></A><H3>
defineColumnType</H3>
<PRE>
public void <B>defineColumnType</B>(int&nbsp;column_index,
                             int&nbsp;type,
                             int&nbsp;max_size)
                      throws java.sql.SQLException</PRE>
<DL>
<DD>Defines the type you will use to retrieve data from a particular database
    table column and the maximum size of data you want.  Depending on the
    value of the dataSizeUnits connection property, max_size will be measured
    in bytes or characters.
    <BR><b>Note for the thin driver</b> : You should only specify the size
    (max_size) for char-type columns and then the unit of max_size is always in
    java chars.<BR>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>column_index</CODE> - <DD><CODE>type</CODE> - <DD><CODE>max_size</CODE> - 
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="defineColumnType(int, int, int, short)"><!-- --></A><H3>
defineColumnType</H3>
<PRE>
public void <B>defineColumnType</B>(int&nbsp;column_index,
                             int&nbsp;type,
                             int&nbsp;max_size,
                             short&nbsp;form_of_use)
                      throws java.sql.SQLException</PRE>
<DL>
<DD>Defines the type you will use to retrieve data from a particular database
    table column and the maximum size of data you want.  Depending on the
    value of the dataSizeUnits connection property, max_size will be measured
    in bytes or characters.
    <BR><b>Note for the thin driver</b> : You should only specify the size
    (max_size) for char-type columns and then the unit of max_size is always in
    java chars.<BR>
    Additionally set the "form of use" parameter which may take the value
    oracle.jdbc.OraclePreparedStatement.FORM_CHAR to specify that the data be
    in the database character set or oracle.jdbc.OraclePreparedStatement.FORM_NCHAR
    to specify that the data be in the national character set.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>column_index</CODE> - <DD><CODE>type</CODE> - <DD><CODE>max_size</CODE> - <DD><CODE>form_of_use</CODE> - 
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE><DT><B>Since:</B></DT>
  <DD>10iR1</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="defineColumnTypeBytes(int, int, int)"><!-- --></A><H3>
defineColumnTypeBytes</H3>
<PRE>
public void <B>defineColumnTypeBytes</B>(int&nbsp;column_index,
                                  int&nbsp;type,
                                  int&nbsp;max_size)
                           throws java.sql.SQLException</PRE>
<DL>
<DD>Defines the type you will use to retrieve data from a particular database
    table column and the maximum size of data you want, specifying the maximum
    size in <b>bytes</b>, not characters. The use of this method is recommended
    if the column is VARCHAR or equivalent and you know the length limit. To
    specify the maximum length in characters, use the
    <code>defineColumnTypeChars</code> method.

    <P>Similarly to <code>defineColumnType(int,int)</CODE>, before executing a
    query you may choose to inform JDBC of the type you will use for fetching
    data from columns and the maximum length of data you desire. Each type of
    data has a default maximum length. This method is useful if you do not wish
    to get the full default length of data.

    <P>If you decide to define column types you have to declare the types of
    exactly all columns in the query. If definitions are missing or too many
    definitions are provided <CODE>executeQuery</CODE> will fail with a
    <CODE>SQLException</CODE>.

    <P>Specifically, the size of the data returned will be the minimum of:
    <ul>
    <li>the maximum field size set in this method
    <li>the maximum field size set in <CODE>setMaxFieldSize()</CODE>
    <li>the natural maximum size of the datatype
    </ul>


    <P>The following example illustrates the use of this feature:

    <P><PRE>
    Statement stmt = conn.createStatement ();
    // Call DefineColumnType to specify that the column will be
    // retrieved as a String to avoid conversion from NUMBER to String
    // on the client side.  This also avoids a round-trip to the
    // database to get the column type.
    //
    // Specify the maximum length of the String.  The values obtained for
    // this column will not exceed this length.
    ((OracleStatement)stmt).defineColumnType (1, Types.VARCHAR, 7);
    ResultSet rset = stmt.executeQuery ("select empno from emp");
    while (rset.next ())
    {
    System.out.println (rset.getString (1));
    }
    </PRE>

    <P>Notes:<ul>

    <li> All columns can be defined to their "natural" JDBC types; in most
    cases, they can be defined to the <CODE>Types.CHAR</CODE> or
    <CODE>Types.VARCHAR</CODE> typecode. You can also use the
    <CODE>OracleTypes</CODE> typecodes. The type can also be different from the
    native type of the column. Appropriate conversions will be done.  A
    subsequent call to <CODE>getObject()</CODE> for this column will return the
    supplied type rather than the native type, however.

    <li>When reading the value of an out parameter you don't have to use the
    <CODE>getXXX</CODE> method whose Java type XXX corresponds to the
    parameter's registered SQL type.  It's just faster if you do as the data
    has already been converted to the right type.

    </ul>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>column_index</CODE> - index of column (first is 1)<DD><CODE>type</CODE> - type to be assigned to column<DD><CODE>max_size</CODE> - maximum length of data for this column
    This value is
    specified in <b>bytes</b>, not characters.
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if an error occurs<DT><B>See Also:</B><DD><A HREF="../../oracle/jdbc/OracleStatement.html#defineColumnType(int, int)"><CODE>defineColumnType(int,int)</CODE></A>, 
<A HREF="../../oracle/jdbc/OracleStatement.html#clearDefines()"><CODE>clearDefines</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="defineColumnTypeChars(int, int, int)"><!-- --></A><H3>
defineColumnTypeChars</H3>
<PRE>
public void <B>defineColumnTypeChars</B>(int&nbsp;column_index,
                                  int&nbsp;type,
                                  int&nbsp;max_size)
                           throws java.sql.SQLException</PRE>
<DL>
<DD>Defines the type you will use to retrieve data from a particular database
    table column and the maximum size of data you want, specifying the maximum
    size in <b>characters</b>, rather than bytes. For non-character types, this
    entrypoint behaves the same as <code>defineColumnType(int,int,int)</code>.

    <P>Similarly to <code>defineColumnType(int,int)</CODE>, before executing a
    query you may choose to inform JDBC of the type you will use for fetching
    data from columns and the maximum length of data you desire. Each type of
    data has a default maximum length. This method is useful if you do not wish
    to get the full default length of data.

    <P>If you decide to define column types you have to declare the types of
    exactly all columns in the query. If definitions are missing or too many
    definitions are provided <CODE>executeQuery</CODE> will fail with a
    <CODE>SQLException</CODE>.

    <P>Specifically, the size of the data returned will be the minimum of:
    <ul>
    <li>the maximum field size set in this method
    <li>the maximum field size set in <CODE>setMaxFieldSize()</CODE>
    <li>the natural maximum size of the datatype
    </ul>

    <P>Notes:<ul>

    <li> All columns can be defined to their "natural" JDBC types; in most
    cases, they can be defined to the <CODE>Types.CHAR</CODE> or
    <CODE>Types.VARCHAR</CODE> typecode. You can also use the
    <CODE>OracleTypes</CODE> typecodes. The type can also be different from the
    native type of the column. Appropriate conversions will be done.  A
    subsequent call to <CODE>getObject()</CODE> for this column will return the
    supplied type rather than the native type, however.

    <li>When reading the value of an out parameter you don't have to use the
    <CODE>getXXX</CODE> method whose Java type XXX corresponds to the
    parameter's registered SQL type.  It's just faster if you do as the data
    has already been converted to the right type.

    </ul>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>column_index</CODE> - index of column (first is 1)<DD><CODE>type</CODE> - type to be assigned to column<DD><CODE>max_size</CODE> - maximum length of data for this column.  This
    value is specified in <b>characters</b>,
    not bytes.
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if an error occurs<DT><B>See Also:</B><DD><A HREF="../../oracle/jdbc/OracleStatement.html#defineColumnType(int, int)"><CODE>defineColumnType(int,int)</CODE></A>, 
<A HREF="../../oracle/jdbc/OracleStatement.html#clearDefines()"><CODE>clearDefines</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="defineColumnType(int, int, java.lang.String)"><!-- --></A><H3>
defineColumnType</H3>
<PRE>
public void <B>defineColumnType</B>(int&nbsp;column_index,
                             int&nbsp;typeCode,
                             java.lang.String&nbsp;typeName)
                      throws java.sql.SQLException</PRE>
<DL>
<DD>Defines the type you will use to retrieve data from a particular database
    table column and specifies the column name. This method should be used for
    structured object, object reference and array columns
    (<CODE>OracleTypes.STRUCT</CODE>, <CODE>OracleTypes.REF_TYPE</CODE> and
    <CODE>OracleTypes.ARRAY</CODE>). The parameter <CODE>typeName</CODE> is
    ignored for other type codes.

    <P>Similarly to <code>defineColumnType(int,int)</CODE>, before executing a
    query you may choose to inform JDBC of the type you will use for fetching
    data from columns.  This will save 2 roundtrips to the RDBMS when executing
    the query as otherwise the JDBC driver has to ask the RDBMS for the column
    types.

    <P>If you decide to define column types you have to declare the types of
    exactly all columns in the query.  If definition are missing or too many
    definitions are provided <CODE>executeQuery</CODE> will fail with a
    SQLException.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>column_index</CODE> - index of column (first is 1)<DD><CODE>typeCode</CODE> - type code for this column.<DD><CODE>typeName</CODE> - specifies the fully-qualified name of the
    column
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if an error occurs<DT><B>See Also:</B><DD><A HREF="../../oracle/jdbc/OracleStatement.html#defineColumnType(int, int)"><CODE>defineColumnType(int,int)</CODE></A>, 
<A HREF="../../oracle/jdbc/OracleStatement.html#clearDefines()"><CODE>clearDefines</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getRowPrefetch()"><!-- --></A><H3>
getRowPrefetch</H3>
<PRE>
public int <B>getRowPrefetch</B>()</PRE>
<DL>
<DD>Retrieves the value or row prefetch for all result sets created from this
    statement.

    <P>The row-prefetching feature associates an integer row-prefetch setting
    with a given statement object. JDBC fetches that number of rows at a time
    from the database during the query. That is, JDBC will fetch N rows that
    match the query criteria and bring them all back to the client at once,
    where N is the prefetch setting. Then, once your <CODE>next</CODE> calls
    have run through those N rows, JDBC will go back to fetch the next N rows
    that match the criteria.

    <P>You can set the number of rows to prefetch for this particular Oracle
    statement (any type of statement). You can also reset the default number of
    rows that will be prefetched for all statements in your connection with the
    <CODE>OracleConnection.setDefaultRowPrefetch</CODE> method.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the row prefetch value<DT><B>See Also:</B><DD><A HREF="../../oracle/jdbc/OracleStatement.html#setRowPrefetch(int)"><CODE>setRowPrefetch</CODE></A>, 
<A HREF="../../oracle/jdbc/OracleConnection.html#setDefaultRowPrefetch(int)"><CODE>OracleConnection.setDefaultRowPrefetch</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setResultSetCache(oracle.jdbc.OracleResultSetCache)"><!-- --></A><H3>
setResultSetCache</H3>
<PRE>
public void <B>setResultSetCache</B>(<A HREF="../../oracle/jdbc/OracleResultSetCache.html" title="interface in oracle.jdbc">OracleResultSetCache</A>&nbsp;cache)
                       throws java.sql.SQLException</PRE>
<DL>
<DD>Lets you use your own client-side cache implementation for scrollable
    result sets. Create your own class that implements the
    <CODE>OracleResultSetCache</CODE> interface, then use this method to input
    an instance of your result set cache class to this statement object that
    will create the result set.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>cache</CODE> - is a OracleResultSetCache instance
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if <CODE>cache</CODE> is <CODE>null</CODE> or if
    an error occurs when calling <CODE>close()</CODE> on <CODE>cache</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="setRowPrefetch(int)"><!-- --></A><H3>
setRowPrefetch</H3>
<PRE>
public void <B>setRowPrefetch</B>(int&nbsp;value)
                    throws java.sql.SQLException</PRE>
<DL>
<DD>Sets the value of row prefetch for all result sets created from this
    statement. It overrides the prefetch value set from the connection, for
    this particular statement.

    <P>The row-prefetching feature associates an integer row-prefetch setting
    with a given statement object. JDBC fetches that number of rows at a time
    from the database during the query. That is, JDBC will fetch N rows that
    match the query criteria and bring them all back to the client at once,
    where N is the prefetch setting. Then, once your <CODE>next</CODE> calls
    have run through those N rows, JDBC will go back to fetch the next N rows
    that match the criteria.

    <p>The row_prefetch will be turned back to 1 automatically
    by the driver if any of the select-column types is
    streaming (long data or long raw data). This is overrides
    any value the user might set. Also, this will be done regardless
    of wether the streaming columns are read or not. <p>

    <P>Notes :<ul>

    <LI>If a column of a result set is of datatype LONG or LONG RAW (that is,
    the streaming types), JDBC changes the statement's row-prefetch setting to
    1, even if you never actually read a value of either of those types.

    <LI>Do not mix the JDBC 2.0 fetch size API and the Oracle row-prefetching
    API in your application. You can use one or the other, but not both.

    </UL>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>value</CODE> - the number of rows to prefetch
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if the argument <tt>value</tt> is <=0<DT><B>See Also:</B><DD><A HREF="../../oracle/jdbc/OracleStatement.html#getRowPrefetch()"><CODE>getRowPrefetch</CODE></A>, 
<A HREF="../../oracle/jdbc/OracleConnection.html#setDefaultRowPrefetch(int)"><CODE>OracleConnection.setDefaultRowPrefetch</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="closeWithKey(java.lang.String)"><!-- --></A><H3>
closeWithKey</H3>
<PRE>
public void <B>closeWithKey</B>(java.lang.String&nbsp;key)
                  throws java.sql.SQLException</PRE>
<DL>
<DD>The underlying cursor is not closed and the Statement
    handle is cached on the Key.  The Statement is cached
    as it is and the state, data, and  meta-data is not cleared.
    The same statement can be retrieved with this Key later.
    Key cannot be null.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - A key to tag to the statement to be retrieved later
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE> - if a database access error occurs</DL>
</DD>
</DL>
<HR>

<A NAME="creationState()"><!-- --></A><H3>
creationState</H3>
<PRE>
public int <B>creationState</B>()</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I></I>&nbsp;
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>Creation Status flag</DL>
</DD>
</DL>
<HR>

<A NAME="isNCHAR(int)"><!-- --></A><H3>
isNCHAR</H3>
<PRE>
public boolean <B>isNCHAR</B>(int&nbsp;index)
                throws java.sql.SQLException</PRE>
<DL>
<DD>isNCHAR (int)
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>index</CODE> - the column index
<DT><B>Returns:</B><DD>true   if the column is of type NCHAR/NVARCHAR/NCLOB
    false  if the column is not of type NCHAR/NVARCHAR/NCLOB
<DT><B>Throws:</B>
<DD><CODE>java.sql.SQLException</CODE></DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Oracle JDBC API Reference<br>10<i>g</i> Release 2 ("10.2.0.1.0")</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../oracle/jdbc/OracleSavepoint.html" title="interface in oracle.jdbc"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../oracle/jdbc/StructMetaData.html" title="interface in oracle.jdbc"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="OracleStatement.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>

</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<center>Copyright &copy; 1998, 2004, Oracle. All rights reserved.</center>
</BODY>
</HTML>
